---
title: DBSCAN -그리드서치 - NMS
tags:
  - 프로젝트
created: 2025-06-13 00:56:49
related_project:
  - "[[감정인식 분류모델]]"
category: sub-project
link:
---
## 요아정 먹방 영상 참고
![tension_curves.png](file:///D:%5Cmy_projects%5Cfunny_clip_classify%5Coutputs%5Cvisualization%5C토핑만_2만_원_정도_넣은_요아정_아이스크림_먹방_merged%5Ctension_curves.png)
## 하이라이트 클러스터링 + 윈도우 샘플링 로직

### 1. 데이터 준비  
- **입력**: 하이라이트 타임스탬프 $[t_i]$ (초 단위)  
- **영상 길이**: $T=16\text{분 }20\text{초}=980\text{초}$

---

### 2. 단일 포인트 보강  
- 단일 하이라이트 $t_h$만 있을 때는  
  - 앞뒤 **3초** 지점에 가상 포인트를 추가  
  - 결과: $\{t_h-3,\;t_h,\;t_h+3\}$  
- **왜?** 단독 피크에도 최소 폭을 확보해 윈도우 다양성 확보

---

### 3. DBSCAN 클러스터링  
- **파라미터**  
  - $\varepsilon=9\text{ s}$  
  - $\mathrm{min\_samples}=1$  
- **원리**  
  - “9초 이내에 연결된 모든 타임스탬프”를 하나의 클러스터로 묶음  
  - 단독 포인트도(보강된 경우 포함) 클러스터로 인정
  - 이번 경우 39개의 클러스터링이 생성됨 

---

### 4. 클러스터 스팬 계산  
각 클러스터 $k$에 대해  
$$[\,s_{\min}^k,\;s_{\max}^k\,]=[\min_i t_i,\;\max_i t_i]$$  
- **의미**: 하이라이트들이 모여 있는 구간의 시작/끝 시각

---

### 5. 윈도우 샘플링  
- **윈도우 길이**  
  $$L=18,19,\dots,40\text{초}$$
- **하이라이트 위치**: 윈도우의 **3/4 지점**  
- **시작 시각 범위**  
  $$\begin{aligned}
    \text{start}_{\min}&=s_{\min}^k-0.75\,L,\\
    \text{start}_{\max}&=s_{\max}^k-0.75\,L.
  \end{aligned}$$
- **슬라이딩**  
  - 간격: **1초**  
  - 시작점: $\lceil\text{start}_{\min}\rceil,\;\dots,\;\lfloor\text{start}_{\max}\rfloor$  
- **경계 처리**  
  $$0\le\text{start}\le T-L$$

> **예시**:  
> 클러스터 span $[20,60]$, $L=20$일 때  
> - $\text{start}_{\min}=20-15=5$, $\text{start}_{\max}=60-15=45$  
> - 윈도우: [5–25], [6–26], …, [45–65] → 총 41개

---

### 6. 전체 샘플 개수  
- **클러스터 수** × **윈도우 길이 종류(23개)**  
- **실제 생성 샘플**: 약 **5,665개**
- 전체 영상 그리드서치할경우 21896개 샘플

---

### 7. 추가 팁  
- **파라미터 튜닝**: $\varepsilon$, 보강 간격(3 s) 등은 실험적 조정  
- **중복 제거**: 클립 간 **IoU**(예: 0.4)로 병합  
- **우선순위 평가**: Fun Score로 상위 클립 추출

---

**직관적 요약**  
1. **가상 보강** → 단독 피크에도 최소 폭 확보  
2. **DBSCAN** → 밀집 구간별 클러스터링  
3. **윈도우 슬라이딩** → 하이라이트를 클립 3/4 지점에 배치  
4. **최종 후보** → 수천 개 윈도우 중 상위 클립 선별  


## NMS 알고리즘
- 5665개의 재미도 점수 평가를 한 후에 고점을 받은 것 중에서 타임스탬프가 너무 붙어있지 않도록 선별하는 알고리즘으로 NMS 알고리즘을 사용.

**NMS(Non-Maximum Suppression)**

1. **후보 윈도우 & 점수 준비**
    
    - 머신러닝 분류기가 매긴 재미도 점수(score)가 있는 윈도우 리스트
        
    - 각 윈도우마다 `[start, end, score]`
        
2. **내림차순 정렬**
    
    - `score` 기준으로 후보들을 내림차순 정렬
        
3. **반복적 억제 과정**
    
    ```pseudo
    selected = []
    while candidates not empty:
      # 1) 가장 높은 score 윈도우 w = pop(candidates)
      selected.append(w)
    
      # 2) 남은 후보 중, w와의 IoU가 τ 이상인 윈도우들은
      #    candidates 에서 모두 제거
      candidates = [c for c in candidates
                    if IoU(c, w) < τ]
    ```
    
    - 여기서 `IoU(c, w) = length(c∩w)/length(c∪w)`
        
    - τ (예: 0.3∼0.5) 이상 겹치는 윈도우는 “너무 붙어 있는” 것으로 간주해 제외
        
4. **결과**
    
    - 서로 충분히 떨어진(겹침이 작은) 최고 재미도 윈도우들만 남게 됨
        

---

### Soft-NMS 변형

- 완전 제거 대신, 겹치는 윈도우들의 점수를 **부드럽게 감소(decay)** 시키는 방법
    
- 겹치는 정도에 따라 `score_new = score_old × exp(−(IoU²)/σ)`
    
- 가까운 구간이지만 약간 겹치는 후보도 살려둘 수 있음
    

---

### 요약

- **Non-Maximum Suppression**으로 “너무 붙어 있는” 윈도우를 걸러낼 수 있고,
    
- **IoU 임계치** τ를 조절해 붙어 있는 정도를 허용하거나 차단할 수 있습니다.
    
- 더 부드러운 처리가 필요하면 **Soft-NMS**를 활용해 보세요.


## 임계치 조언
## NMS IoU 임계치(τ) 추천

- **윈도우 길이**이 18 ∼ 40 초로 다양하고,  
  **1 초 단위**로 슬라이딩했기 때문에  
  작은 겹침도 꽤 긴 시간(예: 6 초 이상)이 될 수 있습니다.

---

### 1. 기본 가이드라인  
- **τ = 0.3** (30 % 겹침 허용)  
  - 윈도우 길이가 20 초라면,  
    \[
      \text{겹침 길이} = 0.3 \times 20 = 6\text{초}
    \]
  - 6 초 이상 겹치는 후보는 “너무 붙어 있음”으로 제거  
- **τ = 0.4 ∼ 0.5** (40 ∼ 50 % 겹침 허용)  
  - 좀 더 여유 있게 겹치는 구간을 남겨두고 싶다면  
  - 20 초 기준 8 ∼ 10 초까지 겹치는 후보도 유지

---

### 2. 영상 특성에 따른 조정  
- **장면 전환이 자주 일어나지 않을 때**  
  - 하나의 하이라이트가 비교적 길게 이어지므로  
  - **τ ≈ 0.4** 정도로 설정해도 무방  
- **짧고 강렬한 장면이 많은 편일 때**  
  - 후보들이 서로 아주 가까이 몰릴 수 있으니  
  - **τ ≈ 0.2 ∼ 0.3** 수준으로 낮춰서 중복 제거 강화

---

침착맨 영상의 경우 긴 호흡의 토크니까 임계치를 0.5정도로 테스트.